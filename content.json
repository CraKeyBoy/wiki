{"pages":[{"title":"Categories","date":"2018-08-20T02:17:49.262Z","path":"categories/index.html","text":""}],"posts":[{"title":"数据结构基本概念","date":"2018-10-10T08:29:10.867Z","path":"wiki/Algorithm/DataStructure/data-structure/","text":"什么是数据结构在计算机科学中，数据结构（data structure）是表示计算机中存储、组织数据的方式，逻辑结构和物理存储结构。 解决问题方法的效率： 跟数据的组织方式有关 跟空间的利用效率有关 跟算法的巧妙程度有关 数据结构的基本功能 如何插入一条新的数据项 如何寻找某一特定的数据项 如何删除某一特定的数据项 如何迭代的访问各个数据项，以便进行显示或其他操作 抽象数据类型（ADT）在编程语言中，常见的几个抽象数据类型如下： 数组 链表 队列 堆栈 字符串 树 图 时间复杂度空间复杂度 参考资料 抽象数据类型","tags":[],"categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://wiki.51itzone.cn/categories/Algorithm/"},{"name":"DataStructure","slug":"Algorithm/DataStructure","permalink":"https://wiki.51itzone.cn/categories/Algorithm/DataStructure/"}]},{"title":"Git 笔记","date":"2018-08-30T11:36:14.741Z","path":"wiki/BasicSkills/GitNotes/","text":"Git介绍 Git是分布式版本控制系统 集中式VS分布式，SVN VS Git SVN 和 Git 主要的区别在于历史版本维护的位置 Git 本地仓库包含代码库还有历史库，在本地的环境开发就可以记录历史而SVN的历史库存在于中央仓库，每次对比与提交代码都必须连接到中央仓库才能进行。 这样的好处在于： 自己可以在脱机环境查看开发的版本历史。 多人开发时如果充当中央仓库的 Git 仓库挂了，可以随时创建一个新的中央仓库然后同步就立刻恢复了中央库。 Git命令Git配置12git config --global user.name \"Your Name\"git config --global user.email \"email@example.com\" git config 命令的 --global 参数，表明这台机器上的所有 Git 仓库都会使用这个配置，也可以对某个仓库指定不同的用户名和邮箱地址。 创建版本库初始化一个Git仓库1git init 添加文件到Git仓库包括两步： 12git add &lt;file&gt;git commit -m \"description\" git add 可以反复多次使用，添加多个文件，git commit 可以一次提交很多文件，-m 后面输入的是本次提交的说明，可以输入任意内容。 查看工作区状态1git status 查看修改内容1git diff 1git diff --cached 1git diff HEAD -- &lt;file&gt; git diff 可以查看工作区(work dict)和暂存区(stage)的区别 git diff --cached 可以查看暂存区(stage)和分支(master)的区别 git diff HEAD -- &lt;file&gt; 可以查看工作区和版本库里面最新版本的区别 查看提交日志1git log 简化日志输出信息 1git log --pretty=oneline 查看命令历史1git reflog 版本回退1git reset --hard HEAD^ 以上命令是返回上一个版本，在Git中，用 HEAD 表示当前版本，上一个版本就是 HEAD^ ，上上一个版本是 HEAD^^ ，往上100个版本写成 HEAD~100。 回退指定版本号1git reset --hard commit_id commit_id 是版本号，是一个用 SHA1 计算出的序列 工作区、暂存区和版本库工作区：在电脑里能看到的目录；版本库：在工作区有一个隐藏目录 .git，是Git的版本库。Git的版本库中存了很多东西，其中最重要的就是称为 stage（或者称为 index ）的暂存区，还有 Git 自动创建的 master，以及指向 master 的指针 HEAD。 进一步解释一些命令： git add 实际上是把文件添加到暂存区 git commit 实际上是把暂存区的所有内容提交到当前分支 撤销修改丢弃工作区的修改1git checkout -- &lt;file&gt; 该命令是指将文件在工作区的修改全部撤销，这里有两种情况： 一种是 file 自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态； 一种是 file 已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。 总之，就是让这个文件回到最近一次 git commit 或 git add 时的状态。 丢弃暂存区的修改分两步：第一步，把暂存区的修改撤销掉(unstage)，重新放回工作区： 1git reset HEAD &lt;file&gt; 第二步，撤销工作区的修改 1git checkout -- &lt;file&gt; 小结： 当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令 git checkout -- &lt;file&gt;。 当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令 git reset HEAD &lt;file&gt;，就回到了第一步，第二步按第一步操作。 已经提交了不合适的修改到版本库时，想要撤销本次提交，进行版本回退，前提是没有推送到远程库。 删除文件1git rm &lt;file&gt; git rm &lt;file&gt; 相当于执行 12rm &lt;file&gt;git add &lt;file&gt; 进一步的解释Q：比如执行了 rm text.txt 误删了怎么恢复？A：执行 git checkout -- text.txt 把版本库的东西重新写回工作区就行了Q：如果执行了 git rm text.txt 我们会发现工作区的 text.txt 也删除了，怎么恢复？A：先撤销暂存区修改，重新放回工作区，然后再从版本库写回到工作区 12git reset head text.txtgit checkout -- text.txt Q：如果真的想从版本库里面删除文件怎么做？A：执行 git commit -m &quot;delete text.txt&quot; ，提交后最新的版本库将不包含这个文件 远程仓库创建 SSH Key1ssh-keygen -t rsa -C \"youremail@example.com\" 关联远程仓库1git remote add origin https://github.com/username/repositoryname.git 推送到远程仓库1git push -u origin master -u 表示第一次推送 master 分支的所有内容，此后，每次本地提交后，只要有必要，就可以使用命令 git push origin master 推送最新修改。 从远程克隆1git clone https://github.com/usern/repositoryname.git 分支创建分支1git branch &lt;branchname&gt; 查看分支1git branch git branch 命令会列出所有分支，当前分支前面会标一个 * 号。 切换分支1git checkout &lt;branchname&gt; 创建+切换分支1git checkout -b &lt;branchname&gt; 合并某分支到当前分支1git merge &lt;branchname&gt; 删除分支1git branch -d &lt;branchname&gt; 查看分支合并图1git log --graph 当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。用 git log --graph 命令可以看到分支合并图。 普通模式合并分支1git merge --no-ff -m \"description\" &lt;branchname&gt; 因为本次合并要创建一个新的commit，所以加上 -m 参数，把commit描述写进去。合并分支时，加上 --no-ff 参数就可以用普通模式合并，能看出来曾经做过合并，包含作者和时间戳等信息，而fast forward合并就看不出来曾经做过合并。 保存工作现场1git stash 查看工作现场1git stash list 恢复工作现场1git stash pop 丢弃一个没有合并过的分支1git branch -D &lt;branchname&gt; 查看远程库信息1git remote -v 在本地创建和远程分支对应的分支1git checkout -b branch-name origin/branch-name， 本地和远程分支的名称最好一致； 建立本地分支和远程分支的关联1git branch --set-upstream branch-name origin/branch-name； 从本地推送分支1git push origin branch-name 如果推送失败，先用 git pull抓取远程的新提交； 从远程抓取分支1git pull 如果有冲突，要先处理冲突。 标签tag 就是一个让人容易记住的有意义的名字，它跟某个 commit 绑在一起。 新建一个标签1git tag &lt;tagname&gt; 命令git tag &lt;tagname&gt;用于新建一个标签，默认为HEAD，也可以指定一个 commit id。 指定标签信息1git tag -a &lt;tagname&gt; -m &lt;description&gt; &lt;branchname&gt; or commit_id git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;可以指定标签信息。 PGP签名标签1git tag -s &lt;tagname&gt; -m &lt;description&gt; &lt;branchname&gt; or commit_id git tag -s &lt;tagname&gt; -m &quot;blablabla...&quot; 可以用 PGP 签名标签。 查看所有标签1git tag 推送一个本地标签1git push origin &lt;tagname&gt; 推送全部未推送过的本地标签1git push origin --tags 删除一个本地标签1git tag -d &lt;tagname&gt; 删除一个远程标签1git push origin :refs/tags/&lt;tagname&gt;","tags":[],"categories":[{"name":"BasicSkills","slug":"BasicSkills","permalink":"https://wiki.51itzone.cn/categories/BasicSkills/"}]},{"title":"ES 分词器","date":"2018-08-29T02:50:32.125Z","path":"wiki/BigData/Elsatic/tokenizer/","text":"分词器","tags":[],"categories":[{"name":"BigData","slug":"BigData","permalink":"https://wiki.51itzone.cn/categories/BigData/"},{"name":"Elsatic","slug":"BigData/Elsatic","permalink":"https://wiki.51itzone.cn/categories/BigData/Elsatic/"}]},{"title":"RabbitMQ 详解","date":"2018-08-20T02:25:16.296Z","path":"wiki/DistributedSystem/Rabbitmq/rabbitmq/","text":"channel 参数详解basicPublish 方法12345678910111213141516171819202122/** * Publish a message. * * Publishing to a non-existent exchange will result in a channel-level * protocol exception, which closes the channel. * * Invocations of &lt;code&gt;Channel#basicPublish&lt;/code&gt; will eventually block if a * &lt;a href=\"http://www.rabbitmq.com/alarms.html\"&gt;resource-driven alarm&lt;/a&gt; is in effect. * * @see com.rabbitmq.client.AMQP.Basic.Publish * @see &lt;a href=\"http://www.rabbitmq.com/alarms.html\"&gt;Resource-driven alarms&lt;/a&gt;. * @param exchange the exchange to publish the message to * @param routingKey the routing key * @param mandatory true if the 'mandatory' flag is to be set * @param immediate true if the 'immediate' flag is to be * set. Note that the RabbitMQ server does not support this flag. * @param props other properties for the message - routing headers etc * @param body the message body * @throws java.io.IOException if an error is encountered */ void basicPublish(String exchange, String routingKey, boolean mandatory, boolean immediate, BasicProperties props, byte[] body) throws IOException; basicAckdeliveryTag: 该消息的indexmultiple：是否批量.true: 将一次性 ack 所有小于 deliveryTag 的消息。 basicNackchannel.basicNack(delivery.getEnvelope().getDeliveryTag(), false, true); deliveryTag: 该消息的 indexmultiple：是否批量.true: 将一次性拒绝所有小于 deliveryTag 的消息。requeue：被拒绝的是否重新入队列 basicRejectchannel.basicReject(delivery.getEnvelope().getDeliveryTag(), false); deliveryTag: 该消息的 indexrequeue：被拒绝的是否重新入队列 channel.basicNack 与 channel.basicReject 的区别： basicNack可以拒绝多条消息，而basicReject一次只能拒绝一条消息","tags":[],"categories":[{"name":"DistributedSystem","slug":"DistributedSystem","permalink":"https://wiki.51itzone.cn/categories/DistributedSystem/"},{"name":"Rabbitmq","slug":"DistributedSystem/Rabbitmq","permalink":"https://wiki.51itzone.cn/categories/DistributedSystem/Rabbitmq/"}]},{"title":"Python 基础","date":"2018-08-20T02:17:49.260Z","path":"wiki/ProgrammingLanguage/Python/python_learn/","text":"什么是 Python 解释器？Python 解析器提供了程序的运行环。Python 是解析执行的，与C/C++之类的编译性语言编写的程序类比，Python 源码不需要从源文件转换成计算机使用的机器语言，也不需要经过连接器链接之后形成二进制可执行文件。当我们运行 Python 程序的时候，Python 解析器将源码转换为字节码，然后再由 Python 解析器来执行这些字节码。但是，Python 程序每次运行都需要转换成字节码，然后再由虚拟机把字节码转换成机器语言，最后才能在硬件上运行。与编译性语言相比，每次多出了编译和链接的过程，性能会受到一定的影响。 官方版本的解释器：CPython。这个解释器是用C语言开发的，所以叫CPython。在命令行下运行 python 命令就是启动 CPython 解释器。 什么是编译型语言和解释型语言 编译型语言实现的，如：C、C++、Fortran、Pascal、Ada。由编译型语言编写的源程序需要经过编译,汇编和链接才能输出目标代码，然后由机器加载到内存中执行目标代码。目标代码是有机器指令组成，不能独立运行，因为源程序中可能使用了一些汇编程序不能解释引用的库函数，而库函数又不在源程序中，此时还需要链接程序完成外部引用和目标模板调用的链接任务，最后才能输出可执行代码。 解释型语言，解释器不产生目标机器代码，而是产生中间代码，这种中间代码与机器代码不同，中间代码的解释是由软件支持的，不能直接使用在硬件上。该软件解释器通常会导致执行效率较低，用解释型语言编写的程序是由另一个可以理解中间代码的解释程序执行的。和编译的程序不同的是, 解释程序的任务是逐一将源代码的语句解释成可执行的机器指令，不需要将源程序翻译成目标代码再执行。对于解释型语言，需要一个专门的解释器来执行该程序， 每条语句只有在执行是才能被翻译，这种解释型语言每执行一次就翻译一次，因而效率低下。 Java 解释器，也称 Java 虚拟机, Java 程序是需要编译的，但是没有直接编译成机器语言，而是编译成字节码， 然后在 Java 虚拟机上用解释的方式执行 Java 字节码。Python 也使用了类似的方式，先将 Python 编译成 Python 字节码，然后由一个专门的 Python 字节码解释器负责解释执行字节码。 Python 是一门解释语言，但是出于效率的考虑，提供了一种编译的方法。编译之后就得到 pyc 文件，存储了字节码。Python 这点和 Java 很类似，但是Java 与 Python 不同的是，Python 是一个解释型的语言，所以编译字节码不是一个强制的操作，事实上，编译是一个自动的过程，一般不会在意它的存在。编译成字节码可以节省加载模块的时间，提高效率。","tags":[],"categories":[{"name":"ProgrammingLanguage","slug":"ProgrammingLanguage","permalink":"https://wiki.51itzone.cn/categories/ProgrammingLanguage/"},{"name":"Python","slug":"ProgrammingLanguage/Python","permalink":"https://wiki.51itzone.cn/categories/ProgrammingLanguage/Python/"}]},{"title":"栈和队列","date":"2018-08-20T02:17:49.259Z","path":"wiki/Algorithm/DataStructure/stcak-and-queue/","text":"栈队列","tags":[],"categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://wiki.51itzone.cn/categories/Algorithm/"},{"name":"DataStructure","slug":"Algorithm/DataStructure","permalink":"https://wiki.51itzone.cn/categories/Algorithm/DataStructure/"}]},{"title":"","date":"2018-08-20T02:17:49.257Z","path":"wiki/BigData/Kafka/kafka/","text":"","tags":[],"categories":[{"name":"BigData","slug":"BigData","permalink":"https://wiki.51itzone.cn/categories/BigData/"},{"name":"Kafka","slug":"BigData/Kafka","permalink":"https://wiki.51itzone.cn/categories/BigData/Kafka/"}]},{"title":"Welcome Javmain's Wiki","date":"2018-08-20T02:17:49.255Z","path":"wiki/index/","text":"这是 Javmain 的个人 Wiki 站点，主要记录学习遇到知识点。 我一直觉得 知识不能碎片化，要结构化，于是希望寻找一种优雅的方式来管理我的知识。 先后了解或尝试过 OneNote、Evernote、Blog、Wiki 等方式，总结了一套觉得比较合理的知识获取吸收管理流程： 通过网页、RSS、微信等网络渠道作为知识获取来源。 通过笔记系统（手写笔记、OneNote、Evernote）初步筛选有价值有针对性的信息，收藏信息，分类整理，做读后要点笔记记录。 自己平时突然想到或总结的一两句话，或很零碎的点子、灵感，初步消化的内容，则用 Wiki 记录。 最后当 Wiki 在某版块有一定量后，将这方面笔记和 Wiki 中的内容重读，整理和提炼，二次消化精炼再加上自己的感悟和理解，写成文章发表在 博客 上。 在使用中，笔记系统 主大块信息的分类和整理，Wiki 主零碎知识的积累，而 博客 只在于 精。 Wiki 中某一版块刚建时，可能只有很少内容或者就一句话，但是通过这种使用流程，日积月累，这方面的事物接触得多了，零散的知识也就多了，那么 Wiki 中这个版块记录的内容也就会变多了，也就是通过积累，把原本大量碎片化的知识结构化整理起来了。 博客的目的是 分享和展示，分享自己的知识，展示自己的水平，需要放拿得出手的东西，因此不适合放碎片化的只言片语，更适合放 一个系列 的总结或者教程等，是一个十分成体系的知识平台。 欢迎大家访问我的博客 Javmain’s Blog","tags":[],"categories":[]},{"title":"线性代数基础","date":"2018-08-20T02:17:49.255Z","path":"wiki/MachineLeaning/math/LinearAlgebra/LinearAlgebraBasic/","text":"线性代数是现代数学的基础之一，在物理、计算机图形学、工程、经济学等自然科学和社会科学各领域具有广泛和深刻的应用，同时线性代数是高等学校理工科各专业的一门重要基础课。本课程介绍求解线性方程组、矩阵理论、向量空间和线性变换等线性代数的基本概念和基本理论，强调线性代数的理论与应用的结合。通过本课程的学习，培养学生的数学逻辑思维和抽象思维能力，使学生具备线性代数的基本理论知识，熟练掌握求解线性方程组和矩阵运算、矩阵分解的基本方法，掌握英文数学术语和表达规范，为后继的学习和提高奠定数学基础。 线性代数(1)围绕求解线性方程组，介绍高斯消元法、矩阵的性质运算和分解、向量空间、正交投影与最小二乘法、行列式的性质与计算、特征值特征向量与矩阵对角化、实对称矩阵的性质等基本知识点。线性代数(1)的知识模块顺序为 向量及其运算简介矩阵和线性方程组高斯消元法矩阵的运算矩阵的逆LU分解向量空间求解齐次线性方程组求解非齐次线性方程组线性无关、基与维数四个基本子空间的基和维数四个基本子空间的正交关系正交投影最小二乘法Gram-Schmidt正交化行列式的基本性质行列式的计算Cramer法则及行列式的几何意义特征值与特征向量矩阵的对角化在微分方程中的应用实对称矩阵 课程参考书有以下几本，其中第一本可做教材： （1）Gilbert Strang, Introduction to linear algebra, Fourth Edition, Wellesley-Cambridge Press, 2009. （2）G. Strang, 线性代数及其应用， 侯自新、郑仲三、张延伦译，南开大学出版社，1990. （3）David C. Lay, Linear Algebra and Its Applications, 机械工业出版社， 2004；中文版：线性代数及其应用（第3版），机械工业出版社，2005. （4）Carl D. Meyer, Matrix Analysis and Applied Linear Algebra, SIAM.","tags":[],"categories":[{"name":"MachineLeaning","slug":"MachineLeaning","permalink":"https://wiki.51itzone.cn/categories/MachineLeaning/"},{"name":"math","slug":"MachineLeaning/math","permalink":"https://wiki.51itzone.cn/categories/MachineLeaning/math/"},{"name":"LinearAlgebra","slug":"MachineLeaning/math/LinearAlgebra","permalink":"https://wiki.51itzone.cn/categories/MachineLeaning/math/LinearAlgebra/"}]}]}