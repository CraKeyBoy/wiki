<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Javmain&#39;s Wiki</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wiki.51itzone.cn/"/>
  <updated>2018-10-10T08:29:10.867Z</updated>
  <id>https://wiki.51itzone.cn/</id>
  
  <author>
    <name>Javmain</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据结构基本概念</title>
    <link href="https://wiki.51itzone.cn/wiki/Algorithm/DataStructure/data-structure/"/>
    <id>https://wiki.51itzone.cn/wiki/Algorithm/DataStructure/data-structure/</id>
    <published>2018-10-10T08:29:10.867Z</published>
    <updated>2018-10-10T08:29:10.867Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是数据结构"><a href="#什么是数据结构" class="headerlink" title="什么是数据结构"></a>什么是数据结构</h1><p>在计算机科学中，数据结构（data structure）是表示计算机中存储、组织数据的方式，逻辑结构和物理存储结构。</p><p>解决问题方法的效率：</p><ul><li>跟数据的组织方式有关</li><li>跟空间的利用效率有关</li><li>跟算法的巧妙程度有关</li></ul><h1 id="数据结构的基本功能"><a href="#数据结构的基本功能" class="headerlink" title="数据结构的基本功能"></a>数据结构的基本功能</h1><ul><li><p>如何插入一条新的数据项</p></li><li><p>如何寻找某一特定的数据项</p></li><li><p>如何删除某一特定的数据项</p></li><li><p>如何迭代的访问各个数据项，以便进行显示或其他操作</p></li></ul><h1 id="抽象数据类型（ADT）"><a href="#抽象数据类型（ADT）" class="headerlink" title="抽象数据类型（ADT）"></a>抽象数据类型（ADT）</h1><p>在编程语言中，常见的几个抽象数据类型如下：</p><ul><li>数组</li><li>链表</li><li>队列</li><li>堆栈</li><li>字符串</li><li>树</li><li>图</li></ul><h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><h1 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h1><blockquote><p>参考资料</p><p><a href="https://zh.wikipedia.org/wiki/%E6%8A%BD%E8%B1%A1%E8%B3%87%E6%96%99%E5%9E%8B%E5%88%A5" rel="external nofollow noopener noreferrer" target="_blank">抽象数据类型</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么是数据结构&quot;&gt;&lt;a href=&quot;#什么是数据结构&quot; class=&quot;headerlink&quot; title=&quot;什么是数据结构&quot;&gt;&lt;/a&gt;什么是数据结构&lt;/h1&gt;&lt;p&gt;在计算机科学中，数据结构（data structure）是表示计算机中存储、组织数据的方式，逻辑结构
      
    
    </summary>
    
      <category term="Algorithm" scheme="https://wiki.51itzone.cn/categories/Algorithm/"/>
    
      <category term="DataStructure" scheme="https://wiki.51itzone.cn/categories/Algorithm/DataStructure/"/>
    
    
  </entry>
  
  <entry>
    <title>Git 笔记</title>
    <link href="https://wiki.51itzone.cn/wiki/BasicSkills/GitNotes/"/>
    <id>https://wiki.51itzone.cn/wiki/BasicSkills/GitNotes/</id>
    <published>2018-08-30T11:36:14.741Z</published>
    <updated>2018-10-10T08:28:18.767Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git介绍"><a href="#Git介绍" class="headerlink" title="Git介绍"></a>Git介绍</h1><ul><li>Git是分布式版本控制系统</li><li>集中式VS分布式，SVN VS Git<ol><li>SVN 和 Git 主要的区别在于历史版本维护的位置</li><li>Git 本地仓库包含代码库还有历史库，在本地的环境开发就可以记录历史而SVN的历史库存在于中央仓库，每次对比与提交代码都必须连接到中央仓库才能进行。</li><li>这样的好处在于：</li></ol></li><li>自己可以在脱机环境查看开发的版本历史。</li><li>多人开发时如果充当中央仓库的 Git 仓库挂了，可以随时创建一个新的中央仓库然后同步就立刻恢复了中央库。</li></ul><h1 id="Git命令"><a href="#Git命令" class="headerlink" title="Git命令"></a>Git命令</h1><h2 id="Git配置"><a href="#Git配置" class="headerlink" title="Git配置"></a>Git配置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">"Your Name"</span></span><br><span class="line">git config --global user.email <span class="string">"email@example.com"</span></span><br></pre></td></tr></table></figure><p><code>git config</code> 命令的 <code>--global</code> 参数，表明这台机器上的所有 Git 仓库都会使用这个配置，也可以对某个仓库指定不同的用户名和邮箱地址。</p><h3 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h3><h4 id="初始化一个Git仓库"><a href="#初始化一个Git仓库" class="headerlink" title="初始化一个Git仓库"></a>初始化一个Git仓库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><h4 id="添加文件到Git仓库"><a href="#添加文件到Git仓库" class="headerlink" title="添加文件到Git仓库"></a>添加文件到Git仓库</h4><p>包括两步：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;file&gt;</span><br><span class="line">git commit -m <span class="string">"description"</span></span><br></pre></td></tr></table></figure><p><code>git add</code> 可以反复多次使用，添加多个文件，<code>git commit</code> 可以一次提交很多文件，<code>-m</code> 后面输入的是本次提交的说明，可以输入任意内容。</p><h3 id="查看工作区状态"><a href="#查看工作区状态" class="headerlink" title="查看工作区状态"></a>查看工作区状态</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><h3 id="查看修改内容"><a href="#查看修改内容" class="headerlink" title="查看修改内容"></a>查看修改内容</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff --cached</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff HEAD -- &lt;file&gt;</span><br></pre></td></tr></table></figure><ul><li><code>git diff</code> 可以查看工作区(work dict)和暂存区(stage)的区别</li><li><code>git diff --cached</code> 可以查看暂存区(stage)和分支(master)的区别</li><li><code>git diff HEAD -- &lt;file&gt;</code> 可以查看工作区和版本库里面最新版本的区别</li></ul><h3 id="查看提交日志"><a href="#查看提交日志" class="headerlink" title="查看提交日志"></a>查看提交日志</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure><p>简化日志输出信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --pretty=oneline</span><br></pre></td></tr></table></figure><h3 id="查看命令历史"><a href="#查看命令历史" class="headerlink" title="查看命令历史"></a>查看命令历史</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure><h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br></pre></td></tr></table></figure><p>以上命令是返回上一个版本，在Git中，用 <code>HEAD</code> 表示当前版本，上一个版本就是 <code>HEAD^</code> ，上上一个版本是 <code>HEAD^^</code> ，往上100个版本写成 <code>HEAD~100</code>。</p><h3 id="回退指定版本号"><a href="#回退指定版本号" class="headerlink" title="回退指定版本号"></a>回退指定版本号</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard commit_id</span><br></pre></td></tr></table></figure><p>commit_id 是版本号，是一个用 SHA1 计算出的序列</p><h3 id="工作区、暂存区和版本库"><a href="#工作区、暂存区和版本库" class="headerlink" title="工作区、暂存区和版本库"></a>工作区、暂存区和版本库</h3><p>工作区：在电脑里能看到的目录；<br>版本库：在工作区有一个隐藏目录 <code>.git</code>，是Git的版本库。<br>Git的版本库中存了很多东西，其中最重要的就是称为 stage（或者称为 index ）的暂存区，还有 Git 自动创建的 <code>master</code>，以及指向  <code>master</code> 的指针 <code>HEAD</code>。</p><p><img src="git-workspace.jpeg" alt="理解"></p><p>进一步解释一些命令：</p><ul><li><code>git add</code> 实际上是把文件添加到暂存区</li><li><code>git commit</code> 实际上是把暂存区的所有内容提交到当前分支</li></ul><h3 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h3><h4 id="丢弃工作区的修改"><a href="#丢弃工作区的修改" class="headerlink" title="丢弃工作区的修改"></a>丢弃工作区的修改</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- &lt;file&gt;</span><br></pre></td></tr></table></figure><p>该命令是指将文件在工作区的修改全部撤销，这里有两种情况：</p><ol><li>一种是 file 自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</li><li>一种是 file 已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</li></ol><p>总之，就是让这个文件回到最近一次 git commit 或 git add 时的状态。</p><h4 id="丢弃暂存区的修改"><a href="#丢弃暂存区的修改" class="headerlink" title="丢弃暂存区的修改"></a>丢弃暂存区的修改</h4><p>分两步：<br>第一步，把暂存区的修改撤销掉(unstage)，重新放回工作区：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD &lt;file&gt;</span><br></pre></td></tr></table></figure><p>第二步，撤销工作区的修改</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- &lt;file&gt;</span><br></pre></td></tr></table></figure><p>小结：</p><ol><li>当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令 <code>git checkout -- &lt;file&gt;</code>。</li><li>当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令 <code>git reset HEAD &lt;file&gt;</code>，就回到了第一步，第二步按第一步操作。</li><li>已经提交了不合适的修改到版本库时，想要撤销本次提交，进行版本回退，前提是没有推送到远程库。</li></ol><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm &lt;file&gt;</span><br></pre></td></tr></table></figure><p><code>git rm &lt;file&gt;</code> 相当于执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm &lt;file&gt;</span><br><span class="line">git add &lt;file&gt;</span><br></pre></td></tr></table></figure><h4 id="进一步的解释"><a href="#进一步的解释" class="headerlink" title="进一步的解释"></a>进一步的解释</h4><p>Q：比如执行了 <code>rm text.txt</code> 误删了怎么恢复？<br>A：执行 <code>git checkout -- text.txt</code> 把版本库的东西重新写回工作区就行了<br>Q：如果执行了 <code>git rm text.txt</code> 我们会发现工作区的 text.txt 也删除了，怎么恢复？<br>A：先撤销暂存区修改，重新放回工作区，然后再从版本库写回到工作区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset head text.txt</span><br><span class="line">git checkout -- text.txt</span><br></pre></td></tr></table></figure><p>Q：如果真的想从版本库里面删除文件怎么做？<br>A：执行 <code>git commit -m &quot;delete text.txt&quot;</code> ，提交后最新的版本库将不包含这个文件</p><h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><h4 id="创建-SSH-Key"><a href="#创建-SSH-Key" class="headerlink" title="创建 SSH Key"></a>创建 SSH Key</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"youremail@example.com"</span></span><br></pre></td></tr></table></figure><h4 id="关联远程仓库"><a href="#关联远程仓库" class="headerlink" title="关联远程仓库"></a>关联远程仓库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin https://github.com/username/repositoryname.git</span><br></pre></td></tr></table></figure><h4 id="推送到远程仓库"><a href="#推送到远程仓库" class="headerlink" title="推送到远程仓库"></a>推送到远程仓库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><p><code>-u</code> 表示第一次推送 master 分支的所有内容，此后，每次本地提交后，只要有必要，就可以使用命令 <code>git push origin master</code> 推送最新修改。</p><h4 id="从远程克隆"><a href="#从远程克隆" class="headerlink" title="从远程克隆"></a>从远程克隆</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/usern/repositoryname.git</span><br></pre></td></tr></table></figure><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><h4 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch &lt;branchname&gt;</span><br></pre></td></tr></table></figure><h4 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure><p><code>git branch</code> 命令会列出所有分支，当前分支前面会标一个 * 号。</p><h4 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;branchname&gt;</span><br></pre></td></tr></table></figure><h4 id="创建-切换分支"><a href="#创建-切换分支" class="headerlink" title="创建+切换分支"></a>创建+切换分支</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b &lt;branchname&gt;</span><br></pre></td></tr></table></figure><h4 id="合并某分支到当前分支"><a href="#合并某分支到当前分支" class="headerlink" title="合并某分支到当前分支"></a>合并某分支到当前分支</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge &lt;branchname&gt;</span><br></pre></td></tr></table></figure><h4 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d &lt;branchname&gt;</span><br></pre></td></tr></table></figure><h4 id="查看分支合并图"><a href="#查看分支合并图" class="headerlink" title="查看分支合并图"></a>查看分支合并图</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --graph</span><br></pre></td></tr></table></figure><p>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。用 <code>git log --graph</code> 命令可以看到分支合并图。</p><h4 id="普通模式合并分支"><a href="#普通模式合并分支" class="headerlink" title="普通模式合并分支"></a>普通模式合并分支</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge --no-ff -m <span class="string">"description"</span> &lt;branchname&gt;</span><br></pre></td></tr></table></figure><p>因为本次合并要创建一个新的commit，所以加上 <code>-m</code> 参数，把commit描述写进去。合并分支时，加上 <code>--no-ff</code> 参数就可以用普通模式合并，能看出来曾经做过合并，包含作者和时间戳等信息，而fast forward合并就看不出来曾经做过合并。</p><h4 id="保存工作现场"><a href="#保存工作现场" class="headerlink" title="保存工作现场"></a>保存工作现场</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure><h4 id="查看工作现场"><a href="#查看工作现场" class="headerlink" title="查看工作现场"></a>查看工作现场</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash list</span><br></pre></td></tr></table></figure><h4 id="恢复工作现场"><a href="#恢复工作现场" class="headerlink" title="恢复工作现场"></a>恢复工作现场</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash pop</span><br></pre></td></tr></table></figure><h4 id="丢弃一个没有合并过的分支"><a href="#丢弃一个没有合并过的分支" class="headerlink" title="丢弃一个没有合并过的分支"></a>丢弃一个没有合并过的分支</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -D &lt;branchname&gt;</span><br></pre></td></tr></table></figure><h4 id="查看远程库信息"><a href="#查看远程库信息" class="headerlink" title="查看远程库信息"></a>查看远程库信息</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure><h4 id="在本地创建和远程分支对应的分支"><a href="#在本地创建和远程分支对应的分支" class="headerlink" title="在本地创建和远程分支对应的分支"></a>在本地创建和远程分支对应的分支</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b branch-name origin/branch-name，</span><br></pre></td></tr></table></figure><p>本地和远程分支的名称最好一致；</p><h4 id="建立本地分支和远程分支的关联"><a href="#建立本地分支和远程分支的关联" class="headerlink" title="建立本地分支和远程分支的关联"></a>建立本地分支和远程分支的关联</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --<span class="built_in">set</span>-upstream branch-name origin/branch-name；</span><br></pre></td></tr></table></figure><h4 id="从本地推送分支"><a href="#从本地推送分支" class="headerlink" title="从本地推送分支"></a>从本地推送分支</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin branch-name</span><br></pre></td></tr></table></figure><p>如果推送失败，先用 git pull抓取远程的新提交；</p><h4 id="从远程抓取分支"><a href="#从远程抓取分支" class="headerlink" title="从远程抓取分支"></a>从远程抓取分支</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure><p>如果有冲突，要先处理冲突。</p><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><p>tag 就是一个让人容易记住的有意义的名字，它跟某个 commit 绑在一起。</p><h4 id="新建一个标签"><a href="#新建一个标签" class="headerlink" title="新建一个标签"></a>新建一个标签</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag &lt;tagname&gt;</span><br></pre></td></tr></table></figure><p>命令<code>git tag &lt;tagname&gt;</code>用于新建一个标签，默认为HEAD，也可以指定一个 commit id。</p><h4 id="指定标签信息"><a href="#指定标签信息" class="headerlink" title="指定标签信息"></a>指定标签信息</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -a &lt;tagname&gt; -m &lt;description&gt; &lt;branchname&gt; or commit_id</span><br></pre></td></tr></table></figure><p><code>git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;</code>可以指定标签信息。</p><h4 id="PGP签名标签"><a href="#PGP签名标签" class="headerlink" title="PGP签名标签"></a>PGP签名标签</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -s &lt;tagname&gt; -m &lt;description&gt; &lt;branchname&gt; or commit_id</span><br></pre></td></tr></table></figure><p><code>git tag -s &lt;tagname&gt; -m &quot;blablabla...&quot;</code> 可以用 PGP 签名标签。</p><h4 id="查看所有标签"><a href="#查看所有标签" class="headerlink" title="查看所有标签"></a>查看所有标签</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag</span><br></pre></td></tr></table></figure><h4 id="推送一个本地标签"><a href="#推送一个本地标签" class="headerlink" title="推送一个本地标签"></a>推送一个本地标签</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin &lt;tagname&gt;</span><br></pre></td></tr></table></figure><h4 id="推送全部未推送过的本地标签"><a href="#推送全部未推送过的本地标签" class="headerlink" title="推送全部未推送过的本地标签"></a>推送全部未推送过的本地标签</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin --tags</span><br></pre></td></tr></table></figure><h4 id="删除一个本地标签"><a href="#删除一个本地标签" class="headerlink" title="删除一个本地标签"></a>删除一个本地标签</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -d &lt;tagname&gt;</span><br></pre></td></tr></table></figure><h4 id="删除一个远程标签"><a href="#删除一个远程标签" class="headerlink" title="删除一个远程标签"></a>删除一个远程标签</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin :refs/tags/&lt;tagname&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Git介绍&quot;&gt;&lt;a href=&quot;#Git介绍&quot; class=&quot;headerlink&quot; title=&quot;Git介绍&quot;&gt;&lt;/a&gt;Git介绍&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Git是分布式版本控制系统&lt;/li&gt;
&lt;li&gt;集中式VS分布式，SVN VS Git&lt;ol&gt;
&lt;li&gt;S
      
    
    </summary>
    
      <category term="BasicSkills" scheme="https://wiki.51itzone.cn/categories/BasicSkills/"/>
    
    
  </entry>
  
  <entry>
    <title>ES 分词器</title>
    <link href="https://wiki.51itzone.cn/wiki/BigData/Elsatic/tokenizer/"/>
    <id>https://wiki.51itzone.cn/wiki/BigData/Elsatic/tokenizer/</id>
    <published>2018-08-29T02:50:32.125Z</published>
    <updated>2018-08-30T10:12:03.294Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分词器"><a href="#分词器" class="headerlink" title="分词器"></a>分词器</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;分词器&quot;&gt;&lt;a href=&quot;#分词器&quot; class=&quot;headerlink&quot; title=&quot;分词器&quot;&gt;&lt;/a&gt;分词器&lt;/h1&gt;
      
    
    </summary>
    
      <category term="BigData" scheme="https://wiki.51itzone.cn/categories/BigData/"/>
    
      <category term="Elsatic" scheme="https://wiki.51itzone.cn/categories/BigData/Elsatic/"/>
    
    
  </entry>
  
  <entry>
    <title>RabbitMQ 详解</title>
    <link href="https://wiki.51itzone.cn/wiki/DistributedSystem/Rabbitmq/rabbitmq/"/>
    <id>https://wiki.51itzone.cn/wiki/DistributedSystem/Rabbitmq/rabbitmq/</id>
    <published>2018-08-20T02:25:16.296Z</published>
    <updated>2018-08-20T11:10:30.351Z</updated>
    
    <content type="html"><![CDATA[<h1 id="channel-参数详解"><a href="#channel-参数详解" class="headerlink" title="channel 参数详解"></a>channel 参数详解</h1><h2 id="basicPublish-方法"><a href="#basicPublish-方法" class="headerlink" title="basicPublish 方法"></a>basicPublish 方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Publish a message.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Publishing to a non-existent exchange will result in a channel-level</span></span><br><span class="line"><span class="comment">     * protocol exception, which closes the channel.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Invocations of &lt;code&gt;Channel#basicPublish&lt;/code&gt; will eventually block if a</span></span><br><span class="line"><span class="comment">     * &lt;a href="http://www.rabbitmq.com/alarms.html"&gt;resource-driven alarm&lt;/a&gt; is in effect.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> com.rabbitmq.client.AMQP.Basic.Publish</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> &lt;a href="http://www.rabbitmq.com/alarms.html"&gt;Resource-driven alarms&lt;/a&gt;.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exchange the exchange to publish the message to</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> routingKey the routing key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mandatory true if the 'mandatory' flag is to be set</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> immediate true if the 'immediate' flag is to be</span></span><br><span class="line"><span class="comment">     * set. Note that the RabbitMQ server does not support this flag.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> props other properties for the message - routing headers etc</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> body the message body</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> java.io.IOException if an error is encountered</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">basicPublish</span><span class="params">(String exchange, String routingKey, <span class="keyword">boolean</span> mandatory, <span class="keyword">boolean</span> immediate, BasicProperties props, <span class="keyword">byte</span>[] body)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><h2 id="basicAck"><a href="#basicAck" class="headerlink" title="basicAck"></a>basicAck</h2><p>deliveryTag: 该消息的index<br>multiple：是否批量.<br>true: 将一次性 ack 所有小于 deliveryTag 的消息。</p><h2 id="basicNack"><a href="#basicNack" class="headerlink" title="basicNack"></a>basicNack</h2><p>channel.basicNack(delivery.getEnvelope().getDeliveryTag(), false, true);</p><p>deliveryTag: 该消息的 index<br>multiple：是否批量.<br>true: 将一次性拒绝所有小于 deliveryTag 的消息。<br>requeue：被拒绝的是否重新入队列</p><h2 id="basicReject"><a href="#basicReject" class="headerlink" title="basicReject"></a>basicReject</h2><p>channel.basicReject(delivery.getEnvelope().getDeliveryTag(), false);</p><p>deliveryTag: 该消息的 index<br>requeue：被拒绝的是否重新入队列</p><p>channel.basicNack 与 channel.basicReject 的区别：</p><blockquote><p>basicNack可以拒绝多条消息，而basicReject一次只能拒绝一条消息</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;channel-参数详解&quot;&gt;&lt;a href=&quot;#channel-参数详解&quot; class=&quot;headerlink&quot; title=&quot;channel 参数详解&quot;&gt;&lt;/a&gt;channel 参数详解&lt;/h1&gt;&lt;h2 id=&quot;basicPublish-方法&quot;&gt;&lt;a href=
      
    
    </summary>
    
      <category term="DistributedSystem" scheme="https://wiki.51itzone.cn/categories/DistributedSystem/"/>
    
      <category term="Rabbitmq" scheme="https://wiki.51itzone.cn/categories/DistributedSystem/Rabbitmq/"/>
    
    
  </entry>
  
  <entry>
    <title>Python 基础</title>
    <link href="https://wiki.51itzone.cn/wiki/ProgrammingLanguage/Python/python_learn/"/>
    <id>https://wiki.51itzone.cn/wiki/ProgrammingLanguage/Python/python_learn/</id>
    <published>2018-08-20T02:17:49.260Z</published>
    <updated>2018-08-20T02:17:49.260Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是-Python-解释器？"><a href="#什么是-Python-解释器？" class="headerlink" title="什么是 Python 解释器？"></a>什么是 Python 解释器？</h1><p>Python 解析器提供了程序的运行环。Python 是解析执行的，与C/C++之类的编译性语言编写的程序类比，Python 源码不需要从源文件转换成计算机使用的机器语言，也不需要经过连接器链接之后形成二进制可执行文件。当我们运行 Python 程序的时候，Python 解析器将源码转换为字节码，然后再由 Python 解析器来执行这些<a href="https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E7%A0%81" rel="external nofollow noopener noreferrer" target="_blank">字节码</a>。但是，Python 程序每次运行都需要转换成字节码，然后再由虚拟机把字节码转换成机器语言，最后才能在硬件上运行。与编译性语言相比，每次多出了编译和链接的过程，性能会受到一定的影响。</p><p>官方版本的解释器：CPython。这个解释器是用C语言开发的，所以叫CPython。在命令行下运行 python 命令就是启动 CPython 解释器。</p><h1 id="什么是编译型语言和解释型语言"><a href="#什么是编译型语言和解释型语言" class="headerlink" title="什么是编译型语言和解释型语言"></a>什么是编译型语言和解释型语言</h1><ul><li><p><strong>编译型语言</strong>实现的，如：C、C++、Fortran、Pascal、Ada。由编译型语言编写的源程序需要经过<strong>编译</strong>,<strong>汇编</strong>和<strong>链接</strong>才能输出目标代码，然后由机器加载到内存中执行目标代码。目标代码是有机器指令组成，不能独立运行，因为源程序中可能使用了一些汇编程序不能解释引用的库函数，而库函数又不在源程序中，此时还需要链接程序完成外部引用和目标模板调用的链接任务，最后才能输出可执行代码。</p></li><li><p><strong>解释型语言</strong>，解释器不产生目标机器代码，而是产生<strong>中间代码</strong>，这种中间代码与机器代码不同，中间代码的解释是由软件支持的，不能直接使用在硬件上。该软件解释器通常会导致执行效率较低，用解释型语言编写的程序是由另一个可以理解中间代码的解释程序执行的。和编译的程序不同的是, 解释程序的任务是逐一将源代码的语句解释成可执行的机器指令，不需要将源程序翻译成目标代码再执行。对于解释型语言，需要一个专门的解释器来执行该程序， 每条语句只有在执行是才能被翻译，这种解释型语言每执行一次就翻译一次，因而效率低下。</p></li><li><p>Java 解释器，也称 <a href="https://zh.wikipedia.org/wiki/Java%E8%99%9A%E6%8B%9F%E6%9C%BA" rel="external nofollow noopener noreferrer" target="_blank">Java 虚拟机</a>, Java 程序是需要编译的，但是没有直接编译成机器语言，而是编译成字节码， 然后在 Java 虚拟机上用解释的方式执行 <a href="https://zh.wikipedia.org/wiki/Java%E5%AD%97%E8%8A%82%E7%A0%81" rel="external nofollow noopener noreferrer" target="_blank">Java 字节码</a>。Python 也使用了类似的方式，先将 Python 编译成 Python 字节码，然后由一个专门的 Python 字节码解释器负责解释执行字节码。</p></li><li><p>Python 是一门解释语言，但是出于效率的考虑，提供了一种编译的方法。编译之后就得到 pyc 文件，存储了字节码。Python 这点和 Java 很类似，但是Java 与 Python 不同的是，Python 是一个解释型的语言，所以编译字节码不是一个强制的操作，事实上，编译是一个自动的过程，一般不会在意它的存在。编译成字节码可以节省加载模块的时间，提高效率。</p></li></ul><p><img src="Java_virtual_machine_architecture.png" alt="Java 虚拟机概貌(图片来源维基百科)"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么是-Python-解释器？&quot;&gt;&lt;a href=&quot;#什么是-Python-解释器？&quot; class=&quot;headerlink&quot; title=&quot;什么是 Python 解释器？&quot;&gt;&lt;/a&gt;什么是 Python 解释器？&lt;/h1&gt;&lt;p&gt;Python 解析器提供了程序的运行
      
    
    </summary>
    
      <category term="ProgrammingLanguage" scheme="https://wiki.51itzone.cn/categories/ProgrammingLanguage/"/>
    
      <category term="Python" scheme="https://wiki.51itzone.cn/categories/ProgrammingLanguage/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>栈和队列</title>
    <link href="https://wiki.51itzone.cn/wiki/Algorithm/DataStructure/stcak-and-queue/"/>
    <id>https://wiki.51itzone.cn/wiki/Algorithm/DataStructure/stcak-and-queue/</id>
    <published>2018-08-20T02:17:49.259Z</published>
    <updated>2018-08-20T02:17:49.259Z</updated>
    
    <content type="html"><![CDATA[<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;栈&quot;&gt;&lt;a href=&quot;#栈&quot; class=&quot;headerlink&quot; title=&quot;栈&quot;&gt;&lt;/a&gt;栈&lt;/h1&gt;&lt;h1 id=&quot;队列&quot;&gt;&lt;a href=&quot;#队列&quot; class=&quot;headerlink&quot; title=&quot;队列&quot;&gt;&lt;/a&gt;队列&lt;/h1&gt;
      
    
    </summary>
    
      <category term="Algorithm" scheme="https://wiki.51itzone.cn/categories/Algorithm/"/>
    
      <category term="DataStructure" scheme="https://wiki.51itzone.cn/categories/Algorithm/DataStructure/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://wiki.51itzone.cn/wiki/BigData/Kafka/kafka/"/>
    <id>https://wiki.51itzone.cn/wiki/BigData/Kafka/kafka/</id>
    <published>2018-08-20T02:17:49.257Z</published>
    <updated>2018-08-20T11:20:20.684Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="BigData" scheme="https://wiki.51itzone.cn/categories/BigData/"/>
    
      <category term="Kafka" scheme="https://wiki.51itzone.cn/categories/BigData/Kafka/"/>
    
    
  </entry>
  
  <entry>
    <title>Welcome Javmain&#39;s Wiki</title>
    <link href="https://wiki.51itzone.cn/wiki/index/"/>
    <id>https://wiki.51itzone.cn/wiki/index/</id>
    <published>2018-08-20T02:17:49.255Z</published>
    <updated>2018-08-20T02:17:49.256Z</updated>
    
    <content type="html"><![CDATA[<p>这是 Javmain 的个人 Wiki 站点，主要记录学习遇到知识点。</p><p>我一直觉得 <strong>知识不能碎片化，要结构化</strong>，于是希望寻找一种优雅的方式来管理我的知识。</p><p>先后了解或尝试过 OneNote、Evernote、Blog、Wiki 等方式，总结了一套觉得比较合理的知识获取吸收管理流程：</p><ol><li>通过网页、RSS、微信等网络渠道作为知识获取来源。</li><li>通过笔记系统（手写笔记、OneNote、Evernote）初步筛选有价值有针对性的信息，<strong>收藏</strong>信息，<strong>分类整理</strong>，做读后<strong>要点</strong>笔记记录。</li><li>自己平时突然想到或总结的一两句话，或很零碎的点子、灵感，初步消化的内容，则用 <strong>Wiki</strong> 记录。</li><li>最后当 Wiki 在某版块有一定量后，将这方面笔记和 Wiki 中的内容重读，整理和提炼，二次消化精炼再加上自己的感悟和理解，写成文章发表在 <strong>博客</strong> 上。</li></ol><p>在使用中，<strong>笔记系统</strong> 主大块信息的<strong>分类和整理</strong>，<strong>Wiki</strong> 主零碎知识的<strong>积累</strong>，而 <strong>博客</strong> 只在于 <strong>精</strong>。</p><p>Wiki 中某一版块刚建时，可能只有很少内容或者就一句话，但是通过这种使用流程，日积月累，这方面的事物接触得多了，零散的知识也就多了，那么 Wiki 中这个版块记录的内容也就会变多了，也就是<strong>通过积累，把原本大量碎片化的知识结构化整理起来了</strong>。</p><p>博客的目的是 <strong>分享和展示</strong>，分享自己的知识，展示自己的水平，需要放拿得出手的东西，因此不适合放碎片化的只言片语，更适合放 <strong>一个系列</strong> 的总结或者教程等，是一个十分成体系的知识平台。</p><p>欢迎大家访问我的博客 <a href="https://blog.51itzone.cn" target="_blank" rel="noopener">Javmain’s Blog</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这是 Javmain 的个人 Wiki 站点，主要记录学习遇到知识点。&lt;/p&gt;
&lt;p&gt;我一直觉得 &lt;strong&gt;知识不能碎片化，要结构化&lt;/strong&gt;，于是希望寻找一种优雅的方式来管理我的知识。&lt;/p&gt;
&lt;p&gt;先后了解或尝试过 OneNote、Evernote、Blo
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>线性代数基础</title>
    <link href="https://wiki.51itzone.cn/wiki/MachineLeaning/math/LinearAlgebra/LinearAlgebraBasic/"/>
    <id>https://wiki.51itzone.cn/wiki/MachineLeaning/math/LinearAlgebra/LinearAlgebraBasic/</id>
    <published>2018-08-20T02:17:49.255Z</published>
    <updated>2018-08-27T07:31:17.900Z</updated>
    
    <content type="html"><![CDATA[<p>线性代数是现代数学的基础之一，在物理、计算机图形学、工程、经济学等自然科学和社会科学各领域具有广泛和深刻的应用，同时线性代数是高等学校理工科各专业的一门重要基础课。本课程介绍求解线性方程组、矩阵理论、向量空间和线性变换等线性代数的基本概念和基本理论，强调线性代数的理论与应用的结合。通过本课程的学习，培养学生的数学逻辑思维和抽象思维能力，使学生具备线性代数的基本理论知识，熟练掌握求解线性方程组和矩阵运算、矩阵分解的基本方法，掌握英文数学术语和表达规范，为后继的学习和提高奠定数学基础。</p><p>线性代数(1)围绕求解线性方程组，介绍高斯消元法、矩阵的性质运算和分解、向量空间、正交投影与最小二乘法、行列式的性质与计算、特征值特征向量与矩阵对角化、实对称矩阵的性质等基本知识点。线性代数(1)的知识模块顺序为</p><h1 id="向量及其运算简介"><a href="#向量及其运算简介" class="headerlink" title="向量及其运算简介"></a>向量及其运算简介</h1><h1 id="矩阵和线性方程组"><a href="#矩阵和线性方程组" class="headerlink" title="矩阵和线性方程组"></a>矩阵和线性方程组</h1><h1 id="高斯消元法"><a href="#高斯消元法" class="headerlink" title="高斯消元法"></a>高斯消元法</h1><h1 id="矩阵的运算"><a href="#矩阵的运算" class="headerlink" title="矩阵的运算"></a>矩阵的运算</h1><h1 id="矩阵的逆"><a href="#矩阵的逆" class="headerlink" title="矩阵的逆"></a>矩阵的逆</h1><h1 id="LU分解"><a href="#LU分解" class="headerlink" title="LU分解"></a>LU分解</h1><h1 id="向量空间"><a href="#向量空间" class="headerlink" title="向量空间"></a>向量空间</h1><h1 id="求解齐次线性方程组"><a href="#求解齐次线性方程组" class="headerlink" title="求解齐次线性方程组"></a>求解齐次线性方程组</h1><h1 id="求解非齐次线性方程组"><a href="#求解非齐次线性方程组" class="headerlink" title="求解非齐次线性方程组"></a>求解非齐次线性方程组</h1><h1 id="线性无关、基与维数"><a href="#线性无关、基与维数" class="headerlink" title="线性无关、基与维数"></a>线性无关、基与维数</h1><h1 id="四个基本子空间的基和维数"><a href="#四个基本子空间的基和维数" class="headerlink" title="四个基本子空间的基和维数"></a>四个基本子空间的基和维数</h1><h1 id="四个基本子空间的正交关系"><a href="#四个基本子空间的正交关系" class="headerlink" title="四个基本子空间的正交关系"></a>四个基本子空间的正交关系</h1><h1 id="正交投影"><a href="#正交投影" class="headerlink" title="正交投影"></a>正交投影</h1><h1 id="最小二乘法"><a href="#最小二乘法" class="headerlink" title="最小二乘法"></a>最小二乘法</h1><h1 id="Gram-Schmidt正交化"><a href="#Gram-Schmidt正交化" class="headerlink" title="Gram-Schmidt正交化"></a>Gram-Schmidt正交化</h1><h1 id="行列式的基本性质"><a href="#行列式的基本性质" class="headerlink" title="行列式的基本性质"></a>行列式的基本性质</h1><h1 id="行列式的计算"><a href="#行列式的计算" class="headerlink" title="行列式的计算"></a>行列式的计算</h1><h1 id="Cramer法则及行列式的几何意义"><a href="#Cramer法则及行列式的几何意义" class="headerlink" title="Cramer法则及行列式的几何意义"></a>Cramer法则及行列式的几何意义</h1><h1 id="特征值与特征向量"><a href="#特征值与特征向量" class="headerlink" title="特征值与特征向量"></a>特征值与特征向量</h1><h1 id="矩阵的对角化"><a href="#矩阵的对角化" class="headerlink" title="矩阵的对角化"></a>矩阵的对角化</h1><h1 id="在微分方程中的应用"><a href="#在微分方程中的应用" class="headerlink" title="在微分方程中的应用"></a>在微分方程中的应用</h1><h1 id="实对称矩阵"><a href="#实对称矩阵" class="headerlink" title="实对称矩阵"></a>实对称矩阵</h1><blockquote><p>课程参考书有以下几本，其中第一本可做教材：</p><p>（1）Gilbert Strang, Introduction to linear algebra, Fourth Edition, Wellesley-Cambridge Press, 2009.</p><p>（2）G. Strang, 线性代数及其应用， 侯自新、郑仲三、张延伦译，南开大学出版社，1990.</p><p>（3）David C. Lay, Linear Algebra and Its Applications, 机械工业出版社， 2004；中文版：线性代数及其应用（第3版），机械工业出版社，2005.</p><p>（4）Carl D. Meyer, Matrix Analysis and Applied Linear Algebra, SIAM.</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;线性代数是现代数学的基础之一，在物理、计算机图形学、工程、经济学等自然科学和社会科学各领域具有广泛和深刻的应用，同时线性代数是高等学校理工科各专业的一门重要基础课。本课程介绍求解线性方程组、矩阵理论、向量空间和线性变换等线性代数的基本概念和基本理论，强调线性代数的理论与应用
      
    
    </summary>
    
      <category term="MachineLeaning" scheme="https://wiki.51itzone.cn/categories/MachineLeaning/"/>
    
      <category term="math" scheme="https://wiki.51itzone.cn/categories/MachineLeaning/math/"/>
    
      <category term="LinearAlgebra" scheme="https://wiki.51itzone.cn/categories/MachineLeaning/math/LinearAlgebra/"/>
    
    
  </entry>
  
</feed>
